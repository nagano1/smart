[
	{
		"testcasename": "cplusplus_test",
		"testname": "stringstream_",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(cplusplus_test, stringstream_) {\r\n    /*\r\n    // Your imaginary buffer\r\n    char    buffer[] = \"A large buffer we don't want t\\n\\no copy but use in a stream\";\r\n\r\n    // An ordinary stream.\r\n    std::stringstream   str;\r\n    std::stringstream   str2;\r\n    str << \"WWOWOWOWO\\n\\nWowowo\";\r\n\r\n    // Get the streams buffer object. Reset the actual buffer being used.\r\n    str.rdbuf()->pubsetbuf(buffer, sizeof(buffer));\r\n    //str << \"WWOWOWOWO\\n\\nWowowo\";\r\n\r\n    std::copy(std::istreambuf_iterator<char>(str),\r\n        std::istreambuf_iterator<char>(),\r\n        std::ostream_iterator<char>(std::cout)\r\n    );\r\n\r\n    std::cout << \"jfiowe\\n\\njfoiaw\";\r\n    */\r\n\r\n\r\n    std::stringstream log;\r\n\r\n    bool stopped = false;\r\n    std::mutex mtx;\r\n\r\n    auto &sstream = log;\r\n    auto worker_thread = std::thread([&]() {\r\n        char temp;\r\n        std::vector<int> v;\r\n        while (!stopped) {\r\n            //printf(\";\");\r\n//\t\t\tstd::this_thread::sleep_for(std::chrono::microseconds(1000));\r\n            {\r\n                std::lock_guard<std::mutex> lg{ mtx };\r\n                std::copy(std::istreambuf_iterator<char>(sstream),\r\n                    std::istreambuf_iterator<char>(),\r\n                    std::ostream_iterator<char>(std::cout)\r\n                );\r\n            }\r\n        }\r\n    });\r\n\r\n    for (int i = 0; i < 10; i++) {\r\n        std::lock_guard<std::mutex> lg{ mtx };\r\n\r\n        log << u8\"日本語a\";\r\n        log << \"C\";\r\n\r\n        // +i % 25);\r\n        // std::this_thread::sleep_for(std::chrono::microseconds(2000));\r\n    }\r\n\r\n\r\n    log << std::feof;\r\n    stopped = true;\r\n    worker_thread.join();\r\n\r\n    EXPECT_EQ(100, 100);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "cplusplus_test",
		"testname": "test1",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(cplusplus_test, test1) {\r\n\r\n    //auto ret = TestUtil::testUtf8Text();\r\n\r\n    //EXPECT_EQ(5, ret);\r\n\r\n    //arrange\r\n    //act\r\n    //assert\r\n    //EXPECT_EQ(1, 1) << \"Vectors x and y are of unequal length\";;\r\n\r\n    //ASSERT_TRUE(true);\r\n\r\n    EXPECT_EQ(20, 20);\r\n    EXPECT_EQ(100, 100);\r\n\r\n    /*\r\n        EXPECT_EQ(Formula::bla(0), 0);\r\n        EXPECT_EQ(Formula::bla(10), 20);\r\n        EXPECT_EQ(Formula::bla(50), 100);\r\n     */\r\n}\r\n\r\n"
	},
	{
		"testcasename": "cplusplus_test",
		"testname": "ArmAssemblyTest2",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(cplusplus_test, ArmAssemblyTest2) {\r\n    int a = 1;\r\n    int b = 2;\r\n    int c = 0;\r\n\r\n    c = add(a, b);\r\n\r\n    printf(\"Result of %d + %d = %d\\n\", a, b, c);\r\n    EXPECT_EQ(c, 3);\r\n    EXPECT_EQ(sysconf(_SC_NPROCESSORS_CONF), 8);\r\n    EXPECT_EQ(sysconf(_SC_NPROCESSORS_ONLN), 8);\r\n\r\n    register void *sp asm(\"sp\");\r\n    void* p2 = NULL;\r\n\r\n\r\n    EXPECT_EQ(sp, (void*)&p2);\r\n}\r\n\r\nstatic int add(int i, int j)\r\n{\r\n    int res = 0;\r\n    /*\r\n    __asm (\"ADD %[result], %[input_i], %[input_j]\"\r\n    : [result] \"=r\" (res) : [input_i] \"r\" (i), [input_j] \"r\" (j)\r\n    );\r\n     */\r\n\r\n    int address = 0;\r\n    /*\r\n     *\r\n    __asm (\"STR sp, [%0]\\n\\t\"\r\n    : \"=r\" ( address)\r\n    );\r\n     */\r\n     /*\r\n         __asm (\"mov %0, sp\\\\n\\\\t\"\r\n         : \"=r\" (address)\r\n         );\r\n      */\r\n\r\n\r\n    long a = 324;\r\n    //EXPECT_EQ(address, 3);\r\n\r\n    return res;\r\n}\r\n\r\n"
	},
	{
		"testcasename": "cplusplus_test",
		"testname": "printFoo",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(cplusplus_test, printFoo) {\r\n    \r\n    GLOG << \"fflush\" << std::fflush;\r\n\r\n    int sleepings = 0;\r\n    sleepings = sleepings | (1 << 0);\r\n    EXPECT_EQ(sleepings, 1);\r\n\r\n    sleepings = sleepings | (1 << 0);\r\n    sleepings = sleepings | (1 << 1);\r\n\r\n    EXPECT_EQ(sleepings, 3);\r\n\r\n    sleepings = sleepings & ~(1 << 0);\r\n    sleepings = sleepings & ~(1 << 1);\r\n\r\n    EXPECT_EQ(sleepings, 0);\r\n\r\n    std::ostringstream output;\r\n    printFoo(output);\r\n\r\n    for (int ki = 0; ki < 100; ki++) {\r\n        //std::this_thread::sleep_for(std::chrono::milliseconds{1});\r\n        //GLOG << std::endl;\r\n\r\n        for (int i = 0; i < 100; i++) {\r\n            //std::this_thread::sleep_for(std::chrono::milliseconds{8});\r\n            //auto *ains = new A();\r\n            //delete ains;\r\n\r\n            //GLOG << i << \",\";\r\n        }\r\n    }\r\n    // Not that familiar with gtest, but I think this is how you test they are\r\n    // equal. Not sure if it will work with stringstream.\r\n    //EXPECT_EQ(output.str(), \"Successful\\n\");\r\n\r\n\r\n    GLOG << \"awfwe 23\";// << std::endl;\r\n\r\n    printf(\"\\nfwe\\n\");\r\n    return;\r\n\r\n    // For reference, this is the equivalent assert in mstest\r\n    // Assert::IsTrue( output == \"Successful\" );\r\n}\r\n\r\n"
	},
	{
		"testcasename": "cplusplus_test",
		"testname": "ThreadQueue",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(cplusplus_test, ThreadQueue) {\r\n    GLOG << \"started: \" << std::fflush;\r\n\r\n    auto start = std::chrono::high_resolution_clock::now().time_since_epoch();\r\n\r\n    ThreadPool tp;\r\n    tp.init();\r\n    tp.start();\r\n\r\n\r\n    std::thread thread1([]() {\r\n\r\n    });\r\n\r\n    std::this_thread::sleep_for(std::chrono::milliseconds{ 1000 });\r\n\r\n    thread1.join();\r\n\r\n    auto elapsed = std::chrono::high_resolution_clock::now().time_since_epoch() - start;\r\n\r\n    auto microseconds = std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count();\r\n    auto diff = microseconds * 1000;\r\n\r\n\r\n    for (int i = 0; i < threads_size; i++) {\r\n        tp.threads[i]->doStop();\r\n    }\r\n\r\n    for (int i = 0; i < threads_size; i++) {\r\n        tp.threads[i]->join();\r\n    }\r\n\r\n\r\n    GLOG << diff << \"diff!\\n\" << \"\\n\";\r\n\r\n    long long count = 0;\r\n    for (int i = 0; i < threads_size; i++) {\r\n        count += tp.threads[i]->set_count;\r\n        std::cout << i << \": \" << tp.threads[i]->set_count << \": \\n\";\r\n    }\r\n\r\n    long long count_b = 0;\r\n    {\r\n        for (int i = 0; i < thread_queue_size; i++) {\r\n            GLOG << \" \\n\";\r\n\r\n            //count_b += tp.thread_queue[i]->lastRunNode.load()->idx;\r\n\r\n            auto *firstNode = POINTER_LOAD(tp.thread_queue[i]->doingRunNode);\r\n            auto *lastNode = POINTER_LOAD(tp.thread_queue[i]->lastRunNode);\r\n\r\n            GLOG << \"queue lastNode->nodeIndex = \" << FormatWithCommas(tp.thread_queue[i]->lastNodeIndex) << std::endl;\r\n\r\n\r\n            int count_temp = -1;\r\n            while (firstNode) {\r\n                count_temp++;\r\n                //printf(\"%d,\", firstNode->nodeIndex.load());\r\n                if (firstNode == lastNode) {\r\n                    GLOG << \"lastNode->nodeIndex = \" << lastNode->nodeIndex << std::endl;\r\n                    break;\r\n                }\r\n                firstNode = firstNode->next;\r\n            }\r\n\r\n            count_b += count_temp;\r\n            //\t\tstd::cout << i << \":: \" << tp.thread_queue[i]->lastRunNode.load()->idx << \"\\n\";// << aobj->gf;\r\n        }\r\n\r\n        GLOG << count << \": count by each thread: \" << \" \" << \"\\n\";\r\n        GLOG << count_b << \": last node counter: \" << \"   !\\n\" << \"\\n\";\r\n        GLOG << diff << \"diff         !\\n\" << \"\\n\";// << aobj->gf;\r\n    }\r\n\r\n    EXPECT_EQ(count, count_b);\r\n    //TestUtil::testUtf8Text();\r\n\r\n\r\n    //std::cout << \"\\set_count = \" << set_count_b << \"\\n\";\r\n    //std::cout << \"\\nconflict = \" << conflict << \"\\n\";\r\n    //std::cout << \"\\nconflict2 = \" << conflict2 << \"\\n\";\r\n\r\n    //_getchar_nolock();\r\n\r\n    if (managed_cmake_test == false) {\n        EXPECT_EQ(\"\", \"Fail to see log\");\r\n    }\r\n}\r\n\r\n"
	},
	{
		"testcasename": "concept",
		"testname": "wakeup_test",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(concept, wakeup_test) {\r\n\r\n    constexpr int sleeping_thread_size = 2;\r\n\r\n    static unsigned long long wakeups[sleeping_thread_size];\r\n    std::atomic<int> side[sleeping_thread_size];\r\n\r\n    static std::condition_variable_any main_sleeper_cond;\r\n    sleepings = 0;\r\n    stopped2 = false;\r\n\r\n\r\n    std::ostringstream output_stream;\r\n\r\n    std::vector<std::thread *> worker_threads;\r\n\r\n    for (int s = 0; s < sleeping_thread_size; s++) {\r\n\r\n        side[s].store(0);\r\n\r\n        wakeups[s] = 0;\r\n\r\n        auto worker_thread = new std::thread([](int index) {\r\n            int this_count = 0;\r\n\r\n            std::mutex this_mtx;\r\n            std::unique_lock<std::mutex> sleeper_lock{ this_mtx };\r\n\r\n            while (true) {\r\n                bool first = true;\r\n                while (true) {\r\n                    auto l = sleepings.load();\r\n                    if (sleepings.compare_exchange_weak(l, l | (1 << index))) {\r\n                        break;\r\n                    }\r\n                    else {\r\n                        if (first == true) {\r\n                            first = false;\r\n                            //printf(\"[\");\r\n                        }\r\n                        //printf(\"w-%d,\",index);\r\n                    }\r\n                }\r\n\r\n                if (stopped2) {\r\n                    break;\r\n                }\r\n\r\n                auto notified = main_sleeper_cond.wait_for(sleeper_lock,\r\n                    std::chrono::milliseconds(1));\r\n\r\n                {\r\n                    bool first = true;\r\n                    while (true) {\r\n                        auto l = sleepings.load();\r\n                        if (sleepings.compare_exchange_weak(l, l & ~(1 << index))) {\r\n                            break;\r\n                        }\r\n                        else {\r\n                            if (first == true) {\r\n                                first = false;\r\n                                //printf(\"[\");\r\n                            }\r\n                            //printf(\"p-%d,\", index);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                //wakeupCount++;\r\n                wakeups[index]++;\r\n                /*\r\n                for (int j = 0; j < 1500; j++) {\r\n                    side[index].store(3335);\r\n                    //int *ml = new int{0};\r\n                    //delete ml;\r\n                    //throw 3;\r\n                }\r\n                */\r\n                //printf(\"%d,\", sleepings.load());\r\n\r\n                //std::this_thread::sleep_for(std::chrono::milliseconds(4));\r\n            }\r\n        }, s);\r\n\r\n        //worker_thread->detach();\r\n        worker_threads.push_back(worker_thread);\r\n    }\r\n\r\n    std::this_thread::sleep_for(std::chrono::microseconds(7000));\r\n\r\n    auto start = std::chrono::high_resolution_clock::now();\r\n\r\n    unsigned long long k = 0;\r\n    using newtype = unsigned int;\r\n    newtype loopCount = ARM ? 1000 * 70 : 1000 * 100;\r\n\r\n    int kk = 8;\r\n    int a = 24;\r\n\r\n    auto current = int{};\r\n\r\n    for (newtype i = 0; i < loopCount; i++) {\r\n        // avoid memory intense access\r\n        if /*constexpr*/ (ARM) {\r\n            for (int p = 0; p < 2050; p++) {\r\n                current = p;\r\n            }\r\n        }\r\n        // atomic<>.load is relatively slow on ARM\r\n        if (sleepings.load(std::memory_order_relaxed) == 0) {\r\n            //k = i;\r\n            k++;\r\n            //tryWakeupCount++;\r\n        }\r\n        else {\r\n            //printf(\"%d,\", sleepings.load());\r\n            //main_sleeper_cond.notify_one();\r\n            main_sleeper_cond.notify_all();\r\n        }\r\n    }\r\n\r\n    stopped2 = true;\r\n\r\n\r\n    //std::chrono::system_clock::now();\r\n    auto elapsed = std::chrono::high_resolution_clock::now() - start;\r\n\r\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count();\r\n\r\n    for (int i = 0; i < sleeping_thread_size; i++) {\r\n        worker_threads[i]->join();\r\n    }\r\n\r\n    uint64_t totalWokeupCount = 0;\r\n    for (int i = 0; i < sleeping_thread_size; i++) {\r\n        totalWokeupCount += wakeups[i];\r\n    }\r\n\r\n\r\n    std::ostringstream output2;\r\n    //output2 << \"[error here]\" << current << std::endl;\r\n    printf(\"k = %d \\n\", k);\r\n    auto one_op_nanosec = nanoseconds / static_cast<float>(loopCount);\r\n    auto wokeupCountPerMillisecond = (double)totalWokeupCount / (nanoseconds);\r\n\r\n    if (speed_test && !EMULATOR) { // thread switching is extremely slow on emulators\r\n        EXPECT_GT(wokeupCountPerMillisecond, ARM ? 10.0f : 5.0f);\r\n        printf(\"wokeupCountPerMillisecond = %f\\n\", wokeupCountPerMillisecond);\r\n    }\r\n\r\n\r\n    GLOG << \"wokeupCountPerMillisecond = \" << wokeupCountPerMillisecond;\r\n    //EXPECT_LT(one_op_nanosec, 43.0f);\r\n    //EXPECT_LT(k, loopCount * 20);\r\n\r\n    //EXPECT_LT(totalWokeupCount, tryWakeupCount);\r\n    //EXPECT_LT(totalWokeupCount, 3000);\r\n    //FAIL() << output2.str() << \":\" << milliseconds << \"ms\" << \",\" << k;\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "concept",
		"testname": "add_consume_test_win32",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(concept, add_consume_test_win32) {\r\n    printf(\"what?\");\r\n    //#ifdef WIN32\r\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\r\n    InterlockedCompareExchange64;\r\n    InitializeConditionVariable;\r\n\r\n    HANDLE h;\r\n\r\n    //HANDLE sh = CreateEvent(NULL, TRUE, FALSE, TEXT(\"EVENT\"));\r\n\r\n    //対象のイベントオブジェクトを取得\r\n    //h = OpenEvent(EVENT_ALL_ACCESS, FALSE, TEXT(\"EVENT\"));\r\n    //シグナル状態になるまで待つ。\r\n    //WaitForSingleObject(h, 1000/*INFINITE*/);\r\n    //非シグナル状態にする。\r\n    //ResetEvent(h);\r\n\r\n\r\n\r\n    InitializeConditionVariable(&ConditionVar);\r\n    InitializeCriticalSection(&CritSection);\r\n\r\n\r\n    HANDLE hThread;\r\n    DWORD dwThreadId;\r\n\r\n    //スレッド起動\r\n    hThread = CreateThread(\r\n        NULL, //セキュリティ属性\r\n        100, //スタックサイズ\r\n        ThreadFunc, //スレッド関数\r\n        NULL, //スレッド関数に渡す引数\r\n        0, //作成オプション(0またはCREATE_SUSPENDED)\r\n        &dwThreadId);//スレッドID\r\n\r\n\r\n    // We are not gonna use this\r\n    //int *a = NULL;\r\n    //int *newValue = new int{ 3 };\r\n    //InterlockedExchangePointerNoFence((PVOID *)&a, newValue);\r\n\r\n\r\n\r\n    // CAS\r\n    int64_t a = 24;\r\n    int64_t newValue = 51234;\r\n    auto metValue = InterlockedCompareExchange64(&a, newValue, 24);\r\n    EXPECT_EQ(metValue, 24);\r\n    if (metValue == 24) {\r\n        // succeed\r\n\r\n    }\r\n    else {\r\n        // failed, but a could be already equivalent to newValue thanks to other thread.\r\n    }\r\n\r\n\r\n\r\n    SuspendThread(hThread);\r\n    Sleep(2);\r\n    ResumeThread(hThread);\r\n\r\n    EnterCriticalSection(&CritSection);\r\n    SleepConditionVariableCS(&ConditionVar, &CritSection, INFINITE/*100*/);\r\n    LeaveCriticalSection(&CritSection);\r\n\r\n\r\n\r\n\r\n    WaitForSingleObject(hThread, 10000);\r\n\r\n    CloseHandle(hThread);\r\n\r\n    //FAIL();\r\n#endif\r\n}\r\n"
	},
	{
		"testcasename": "concept",
		"testname": "add_consume_test",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(concept, add_consume_test) {\r\n\r\n    // Let's measure time for two threads to communicate via a work queue\r\n\r\n\r\n    using newtype = unsigned int;\r\n\r\n    static int work_node_max = ARM ? 2050 * 2 : 1800 * 1;\r\n\r\n    static std::atomic<bool> wow2{ false };\r\n\r\n    static constexpr int SET_VALUE = 11;\r\n\r\n    newtype loopCount = work_node_max;// ARM ? 1000 * 70 : 1000 * 100;\r\n    newtype outLoop = ARM ? 1000 * 1 : 100 * 1;\r\n    static int total_i = 0;\r\n    total_i = 0;\r\n\r\n    static long long total_nano_sec = 0;\r\n    total_nano_sec = 0;\r\n\r\n    static long long total_calc = 0;\r\n    total_calc = 0;\r\n\r\n\r\n\r\n    //#pragma pack(8)\r\n    struct WorkItem {\r\n        std::atomic<WorkItem*> next{ nullptr };\r\n\r\n        // incremental flag to deal with cache\r\n        uint64_t serverRevision = 0;\r\n        uint64_t clientRevision = 0;\r\n\r\n        //uint64_t serverLocalId = 10;\r\n\r\n        //uint32_t sessionIndex = 0;\r\n        std::atomic<int> finished{ -1 };\r\n\r\n        /*\r\n        int value16;\r\n        int value17;\r\n        int value18;\r\n        int value19;\r\n        int value20;\r\n        int value21;\r\n        int value22;\r\n        int value23;\r\n        int value24;\r\n        int value25;\r\n        int value26;\r\n        int value27;\r\n        int value28;\r\n        int value29;\r\n        int value30;\r\n        int value31;\r\n        */\r\n\r\n\r\n        char value0;\r\n        char value1;\r\n        char value2;\r\n        char value3;\r\n        char value4;\r\n        char value5;\r\n        char value6;\r\n        char value7;\r\n        char value8;\r\n        char value9;\r\n        char value10;\r\n        char value11;\r\n        char value12;\r\n        char value13;\r\n        char value14;\r\n        char value15;\r\n\r\n\r\n        /*\r\n        int val2[8];\r\n        int val32[16];\r\n        int val42[16];\r\n        int val52[16];\r\n        uint16_t arr[16];\r\n        uint16_t arr0[16];\r\n        uint16_t arr1[16];\r\n        uint16_t arr2[16];\r\n*/\r\n    };\r\n\r\n\r\n\r\n    auto *cacheVec = new std::vector<WorkItem *>{};\r\n    {\r\n        for (int i = 0; i < work_node_max; i++) {\r\n            auto *newLastItem = new WorkItem();\r\n            cacheVec->push_back(newLastItem);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    for (int ntry = 0; ntry < outLoop; ntry++) {\r\n\r\n        for (int jj = 0; jj < 1; jj++) {\r\n\r\n            for (int k = 0; k < cacheVec->size(); k++) {\r\n                auto &&aa = cacheVec->at(k);\r\n                //aa->sessionIndex = 3;\r\n\r\n                const int gk = -3 - jj;\r\n                aa->value15 = gk + 8;\r\n                aa->value0 = gk + 8;\r\n                aa->value1 = gk + 8;\r\n                aa->value2 = gk + 8;\r\n                aa->value3 = gk + 8;\r\n                aa->value4 = gk + 8;\r\n                aa->value5 = gk + 8;\r\n                aa->value6 = gk + 8;\r\n                aa->value7 = gk + 8;\r\n                aa->value8 = gk + 8;\r\n                aa->value9 = gk + 8;\r\n                aa->value10 = gk + 8;\r\n                aa->value11 = gk + 8;\r\n                aa->value12 = gk + 8;\r\n                aa->value13 = gk + 8;\r\n                aa->value14 = gk + 8;\r\n            };\r\n        }\r\n\r\n\r\n        WorkItem *firstItem = new WorkItem{};\r\n\r\n\r\n        std::mt19937 get_rand_mt;\r\n        //std::shuffle(cacheVec->begin(), cacheVec->end(), get_rand_mt);\r\n\r\n        std::atomic_thread_fence(std::memory_order_release);\r\n\r\n        auto add_thread = std::thread(\r\n            [](int index, WorkItem *firstItem, std::vector<WorkItem *>* cacheVec) {\r\n\r\n\r\n            WorkItem *currentItem = firstItem;\r\n\r\n            // Add work queues\r\n            for (auto&&item : *cacheVec) {\r\n                item->next.store(nullptr, std::memory_order_relaxed);\r\n                item->finished.store(-1, std::memory_order_relaxed);\r\n                item->serverRevision++;\r\n\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n\r\n                currentItem->next.store(item, std::memory_order_relaxed);\r\n\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n\r\n\r\n\r\n                constexpr int k = 3;\r\n                item->value0 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value1 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value2 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value3 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value4 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value5 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value6 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value7 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value8 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value9 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value10 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value11 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value12 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value13 = k + 8;\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n                item->value14 = k + 8;\r\n\r\n                std::atomic_thread_fence(std::memory_order_release);\r\n\r\n                item->value15 = k + 8;\r\n\r\n                currentItem = item;\r\n            }\r\n            currentItem->finished.store(15, std::memory_order_relaxed);\r\n\r\n            std::atomic_thread_fence(std::memory_order_release);\r\n\r\n\r\n\r\n        }, 3, firstItem, cacheVec);\r\n\r\n        add_thread.join();\r\n\r\n        // std::this_thread::sleep_for(std::chrono::milliseconds{ 1 });\r\n\r\n\r\n        auto consume_thread = std::thread([](int index, WorkItem *firstItem) {\r\n\r\n            auto start = std::chrono::high_resolution_clock::now();\r\n\r\n            int i_sum = 0;\r\n            auto *targetItem = firstItem;\r\n            int i = 0;\r\n            while (true) {\r\n                std::atomic_thread_fence(std::memory_order_acquire);\r\n\r\n                auto *tempNext = targetItem->next.load(std::memory_order_relaxed);\r\n                if (tempNext != nullptr\r\n                    //&& tempNext->clientRevision+1 == tempNext->serverRevision\r\n                    ) {\r\n\r\n                    if (tempNext->clientRevision + 1 != tempNext->serverRevision)\r\n                    {\r\n                        FAIL();\r\n                    }\r\n\r\n                    i_sum++;\r\n                    targetItem = tempNext;\r\n                    targetItem->clientRevision++;\r\n\r\n\r\n                    if (targetItem->value15 == SET_VALUE) {\r\n\r\n                        std::atomic_thread_fence(std::memory_order_acquire);\r\n\r\n                        if (\r\n                            targetItem->value0 == SET_VALUE\r\n                            && targetItem->value5 == SET_VALUE\r\n                            && targetItem->value6 == SET_VALUE\r\n                            && targetItem->value7 == SET_VALUE\r\n                            && targetItem->value8 == SET_VALUE\r\n                            && targetItem->value9 == SET_VALUE\r\n                            && targetItem->value1 == SET_VALUE\r\n                            && targetItem->value2 == SET_VALUE\r\n                            && targetItem->value3 == SET_VALUE\r\n                            && targetItem->value4 == SET_VALUE\r\n                            && targetItem->value10 == SET_VALUE\r\n                            && targetItem->value11 == SET_VALUE\r\n                            && targetItem->value12 == SET_VALUE\r\n                            && targetItem->value13 == SET_VALUE\r\n                            && targetItem->value14 == SET_VALUE\r\n                            /*\r\n                            && targetItem->value16 == SET_VALUE\r\n                            && targetItem->value17 == SET_VALUE\r\n                            && targetItem->value18 == SET_VALUE\r\n                            && targetItem->value19 == SET_VALUE\r\n                            && targetItem->value20 == SET_VALUE\r\n                            && targetItem->value21 == SET_VALUE\r\n                            && targetItem->value22 == SET_VALUE\r\n                            && targetItem->value23 == SET_VALUE\r\n                            && targetItem->value24 == SET_VALUE\r\n                            && targetItem->value25 == SET_VALUE\r\n                            && targetItem->value26 == SET_VALUE\r\n                            && targetItem->value27 == SET_VALUE\r\n                            && targetItem->value28 == SET_VALUE\r\n                            && targetItem->value29 == SET_VALUE\r\n                            && targetItem->value30 == SET_VALUE\r\n                            */\r\n\r\n                            )\r\n                        {\r\n\r\n                        }\r\n                        else {\r\n                            //FAIL();\r\n                        }\r\n                    }\r\n\r\n\r\n                    if (targetItem->value15 != SET_VALUE) {\r\n                        i++;\r\n\r\n                        {\r\n                            int try_n = 0;\r\n                            volatile int vi = 0;\r\n                            while (true) {\r\n                                vi++;\r\n\r\n                                if (ARM) {\r\n                                    wow2.store(!wow2.load(), std::memory_order_relaxed);\r\n                                }\r\n                                else {\r\n                                    do_pause_or_nothing();\r\n                                }\r\n\r\n                                if (SET_VALUE == targetItem->value15) {\r\n                                    i--;\r\n                                    break;\r\n                                }\r\n\r\n                                try_n++;\r\n                                if (try_n > 300) {\r\n                                    int try_n2 = 0;\r\n                                    while (true) {\r\n                                        std::this_thread::sleep_for(\r\n                                            std::chrono::milliseconds{ 0 }\r\n                                        );\r\n                                        if (SET_VALUE == targetItem->value15) {\r\n                                            i--;\r\n                                            break;\r\n                                        }\r\n\r\n                                        try_n2++;\r\n\r\n                                        if (try_n2 > 9) {\r\n                                            while (true) {\r\n                                                if (SET_VALUE == targetItem->value15) {\r\n                                                    i--;\r\n                                                    break;\r\n                                                }\r\n                                                std::this_thread::sleep_for(std::chrono::milliseconds{ 1 });\r\n                                            }\r\n\r\n                                            break;\r\n                                        }\r\n                                    }\r\n\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (targetItem->finished.load(std::memory_order_relaxed) == 15) {\r\n                        break;\r\n                    }\r\n                    else {\r\n                        wow2.store(!wow2.load(), std::memory_order_relaxed);\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            total_i += i;\r\n\r\n\r\n\r\n            auto elapsed = std::chrono::high_resolution_clock::now() - start;\r\n            auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n            total_nano_sec += nanoseconds;\r\n\r\n            total_calc += i_sum;\r\n\r\n        }, 3, firstItem);\r\n\r\n        //add_thread.join();\r\n        consume_thread.join();\r\n\r\n    }\r\n\r\n    // dispose\r\n    for (auto&&item : *cacheVec) {\r\n        delete item;\r\n    }\r\n    delete cacheVec;\r\n\r\n    auto one_op_nanosec = total_nano_sec / static_cast<float>(loopCount*outLoop * 16);\r\n\r\n    EXPECT_EQ(total_i, 0);\r\n    EXPECT_EQ(total_calc, outLoop*loopCount);\r\n\r\n    if (speed_test) {\r\n        EXPECT_LT(one_op_nanosec, ARM ? 35 : 1);\r\n    }\r\n\r\n\r\n    std::cout << one_op_nanosec << \": nanosec-----------------------------\";\r\n\r\n    if (managed_cmake_test == false) {\n        EXPECT_EQ(\"\", \"Fail to see log\");\r\n    }\n}\r\n\r\n"
	},
	{
		"testcasename": "concept",
		"testname": "unordered_map_test",
		"filepath": "tests/google_tests/cplusplus_test.cpp",
		"filename": "cplusplus_test.cpp",
		"body": "TEST(concept, unordered_map_test) {\r\n\r\n    auto map = new std::unordered_map<int, int>();\r\n    //map->reserve(1000 * 1000);\r\n    int loopCount = 1000 * 10;\r\n    for (int i = 0; i < loopCount; i++) {\r\n        map->insert(std::make_pair(i, i + 1));\r\n    }\r\n\r\n    auto start = std::chrono::high_resolution_clock::now();\r\n\r\n    int result = 0;\r\n    for (int i = 0; i < loopCount; i++) {\r\n        result = map->at(i);\r\n    }\r\n\r\n    auto elapsed = std::chrono::high_resolution_clock::now() - start;\r\n\r\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n\r\n    auto one_op_nanosec = nanoseconds / static_cast<float>(loopCount);\r\n\r\n    if (speed_test) {\r\n        EXPECT_LT(one_op_nanosec, 100);\r\n        printf(\"%f\", one_op_nanosec);\r\n    }\r\n    EXPECT_EQ(result, loopCount);\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "JsonParseTest",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, JsonParseTest) {\n\n    // preserve spaces and line-breaks\n    char *text = const_cast<char *>(u8R\"(\n{\"jsonrpc\":\"2.0\",\"id\":0,\"method\":\"initialize\",\"params\":{\"processId\":28196,\"rootPath\":null,\"rootUri\":null,\"capabilities\":{\"workspace\":{\"applyEdit\":true,\"workspaceEdit\":{\"documentChanges\":true},\"didChangeConfiguration\":{\"dynamicRegistration\":true},\"didChangeWatchedFiles\":{\"dynamicRegistration\":true},\"symbol\":{\"dynamicRegistration\":true,\"symbolKind\":{\"valueSet\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},\"executeCommand\":{\"dynamicRegistration\":true},\"configuration\":true,\"workspaceFolders\":true},\"textDocument\":{\"publishDiagnostics\":{\"relatedInformation\":true},\"synchronization\":{\"dynamicRegistration\":true,\"willSave\":true,\"willSaveWaitUntil\":true,\"didSave\":true},\"completion\":{\"dynamicRegistration\":true,\"contextSupport\":true,\"completionItem\":{\"snippetSupport\":true,\"commitCharactersSupport\":true,\"documentationFormat\":[\"markdown\",\"plaintext\"],\"deprecatedSupport\":true},\"completionItemKind\":{\"valueSet\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]}},\"hover\":{\"dynamicRegistration\":true,\"contentFormat\":[\"markdown\",\"plaintext\"]},\"signatureHelp\":{\"dynamicRegistration\":true,\"signatureInformation\":{\"documentationFormat\":[\"markdown\",\"plaintext\"]}},\"definition\":{\"dynamicRegistration\":true},\"references\":{\"dynamicRegistration\":true},\"documentHighlight\":{\"dynamicRegistration\":true},\"documentSymbol\":{\"dynamicRegistration\":true,\"symbolKind\":{\"valueSet\":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26]}},\"codeAction\":{\"dynamicRegistration\":true},\"codeLens\":{\"dynamicRegistration\":true},\"formatting\":{\"dynamicRegistration\":true},\"rangeFormatting\":{\"dynamicRegistration\":true},\"onTypeFormatting\":{\"dynamicRegistration\":true},\"rename\":{\"dynamicRegistration\":true},\"documentLink\":{\"dynamicRegistration\":true},\"typeDefinition\":{\"dynamicRegistration\":true},\"implementation\":{\"dynamicRegistration\":true},\"colorProvider\":{\"dynamicRegistration\":true}}},\"trace\":\"off\",\"workspaceFolders\":null}}\n)\");\n    testJson(text);\n\n\n\n    {\n        char *text = const_cast<char *>(u8R\"( {\"jsonrpc\":\"2.0\", \"method\" : \"initialized\n)\");\n        auto *document = Alloc::newDocument(DocumentType::JsonDocument, nullptr);\n        DocumentUtils::parseText(document, text, strlen(text));\n\n\n        EXPECT_EQ(document->context->syntaxErrorInfo.hasError, true);\n        EXPECT_EQ(document->context->syntaxErrorInfo.errorCode, 21390);\n        EXPECT_EQ(std::string{ document->context->syntaxErrorInfo.reason }, std::string{ \"no end quote\" });\n    }\n\n\n\n    {\n        char *text = const_cast<char *>(u8R\"( {\"jsonrpc\":\"2.0\", \"method\" : \"initialized\"})\");\n        auto *document = Alloc::newDocument(DocumentType::JsonDocument, nullptr);\n        DocumentUtils::parseText(document, text, strlen(text));\n        auto *rootJson = Cast::downcast<JsonObjectStruct*>(document->firstRootNode);\n        EXPECT_NE(rootJson, nullptr);\n\n        DocumentUtils::generateHashTables(document);\n        auto *item = rootJson->hashMap->get2(\"method\");\n\n        EXPECT_NE(item, nullptr);\n        EXPECT_EQ(item->vtable, VTables::StringLiteralVTable);\n\n        auto *strNode = Cast::downcast<StringLiteralNodeStruct*>(item);\n        EXPECT_EQ(std::string{ strNode->text }, std::string{ \"\\\"initialized\\\"\" });\n    }\n\n\n\n\n\n\n\n    /*\n     *   DocumentUtils::performCodingOperation\n     */\n\n    {\n        char *text = const_cast<char *>(u8R\"(\n{\n\"jsonrpc\":\"2.0\",\n                    \"jsonrpc2\":\"2.0\",\n                                        \"jsonrpc3\": {\n\"a\":\"日本語\"\n}\n}\n)\");\n\n        char *autoIndentedText = const_cast<char *>(u8R\"(\n{\n    \"jsonrpc\":\"2.0\",\n    \"jsonrpc2\":\"2.0\",\n    \"jsonrpc3\": {\n        \"a\":\"日本語\"\n    }\n}\n)\");\n        auto *document = Alloc::newDocument(DocumentType::JsonDocument, nullptr);\n        DocumentUtils::parseText(document, text, strlen(text));\n        DocumentUtils::generateHashTables(document);\n        \n        auto *rootJson = Cast::downcast<JsonObjectStruct*>(document->firstRootNode);\n        auto *item = rootJson->firstKeyValueItem->keyNode;\n        if (item) {\n            EXPECT_EQ(item->vtable, VTables::JsonObjectKeyVTable);\n            DocumentUtils::performCodingOperation(\n                CodingOperations::IndentSelection\n                , document, Cast::upcast(document->firstRootNode), Cast::upcast(&document->endOfFile));\n        }\n\n\n        char *treeText = DocumentUtils::getTextFromTree(document);\n        EXPECT_EQ(std::string{ treeText }, std::string{ autoIndentedText });\n    }\n\n\n\n\n\n    /*\n     *   DocumentUtils::performCodingOperation\n     */\n\n    {\n        char *text = const_cast<char *>(u8R\"(\nclass A\n{\nclass B\n{\n\n}\n}\n)\");\n\n        char *autoIndentedText = const_cast<char *>(u8R\"(\nclass A\n{\n    class B\n    {\n\n    }\n}\n)\");\n        auto *document = Alloc::newDocument(DocumentType::CodeDocument, nullptr);\n        DocumentUtils::parseText(document, text, strlen(text));\n        DocumentUtils::performCodingOperation(\n            CodingOperations::IndentSelection\n            , document, Cast::upcast(document->firstRootNode), Cast::upcast(&document->endOfFile)\n        );\n\n\n        char *treeText = DocumentUtils::getTextFromTree(document);\n        EXPECT_EQ(std::string{ treeText }, std::string{ autoIndentedText });\n    }\n\n\n\n\n    /*\n    {\n        char *text = const_cast<char *>(u8R\"({\"jsonrpc\":\"2.0\", \"method\" : \"textDocument/didOpen\", \"params\" : {\"textDocument\":{\"uri\":\"file:///c%3A/Users/wikihow/Desktop/AAA.txt\", \"languageId\" : \"plaintext\", \"version\" : 1, \"text\" : \"AAA\\r\\n\\r\\n\\r\\n\\r\\nBBB\\r\\nCCC\\r\\nAAA\\r\\nBBB\"}}})\");\n        testJson(text);\n    }\n    */\n\n\n    // follow indent rule\n    {\n        text = const_cast<char *>(u8R\"(\n{\n        \"aowowo\" :    21249,\n\"jio fw\" : null,\n            \"text\" : \"日本語\"\n            , \"ijofw\": [2134\n                  \t    ,\n                            \"test\", true,\n                        null,\n                        {\"君はどうなんだろう\": [true]}\n            ]\n\n})\");\n        testJson(text);\n    }\n\n    text = const_cast<char *>(u8R\"({\"aowfowo\" : 21249, \"jiofw\": false})\");\n    testJson(text);\n\n\n\n    testJson(\"{}\");    // empty json object\n    testJson(\"[]\");    // empty json array\n    testJson(\"[298341,12432134, true, false, \\\"fwo\\\", null]\");\n\n    testJson(u8R\"({\"empty_array\" : [\n            421,true, \"ijofwe\", null,false]})\");\n\n    // nested json object\n    text = const_cast<char *>(u8R\"({\"jfoiw\": { \"fjioew\"  :   { \"jfiow\": true } \n\n        } \n\n            })\");\n    testJson(text);\n\n\n\n    // last comma is allowed\n    text = const_cast<char *>(u8R\"({\"jfoiw\": true\n\n    , \n}\n)\");\n    testJson(text);\n}\n\nstatic void testJson(const char* codeText) {\n    auto *document = Alloc::newDocument(DocumentType::JsonDocument, nullptr);\n    DocumentUtils::parseText(document, codeText, strlen(codeText));\n    //char *typeText = DocumentUtils::getTypeTextFromTree(document);\n    //    if (typeText != nullptr) {\n            //EXPECT_EQ(std::string{ typeText }, std::string{ \"fjow\" });\n        //}\n\n    char *treeText = DocumentUtils::getTextFromTree(document);\n    DocumentUtils::generateHashTables(document);\n    /*\n    auto *jsonObject = DocumentUtils::generateHashTables(document);\n    if (jsonObject) {\n        auto *item = jsonObject->hashMap->get2(\"aowfowo\");\n        printf(\"item - %d\", item);\n    }\n    */\n\n    //if (treeText != nullptr) {\n        //Allocator::deleteDocument(document);\n        // EXPECT_EQ(std::string(treeText), \"\\n{b:18}\\n\");\n    EXPECT_EQ(std::string{ treeText }, std::string{ codeText });\n    //}\n\n}\n\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "char_iteration",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, char_iteration) {\n\n    std::string wstr{ u8\"auto * 😂日本語たち=10234;\" };\n    std::string wstr2{ \"class TestClass{ }\" };\n    int alen = wstr.length();\n    auto chs = std::vector<char>{};\n\n    //chs.push_back(0xEF);\n    //chs.push_back(0xBB);\n    //chs.push_back(0xBF);\n\n    //std::cout << \"\\n[\" << wstr.length() << \"\\n\";\n\n    auto &&val = std::move(23);\n\n    char *text = const_cast<char *>(wstr.c_str());\n    for (int i = 0; true; i++) {\n        auto ch = text[i];\n        if (ch == '\\0') {\n            //printf(\"TestImpl : %d, %d\", i, alen);\n            break;\n        }\n\n        if ((ch & 0x80) != 0x80) {\n            // if (ch >> 7 == 0) {\n            // if (ch  <= 0x7F) {\n\n            //printf(\"ch = %c\\n\", ch);\n\n        }\n        else {\n            // printf(\"jap ch = %c\\n\", ch);\n            chs.push_back(ch);\n        }\n    }\n\n    chs.push_back('\\0');\n    std::string parsed_text{ &chs[0] };\n\n    EXPECT_EQ(chs.size(), 20);\n\n    if (ARM) {\n        // This might cause crash on old android devices\n        //EXPECT_EQ(parsed_text, \"😂日本語たち\");\n    }\n\n    // printf(\"japanese text = %s, \", a);\n}\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "utf16Length",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, utf16Length) {\n\n    // Table 3-8.  Use of U+FFFD in UTF-8 Conversion\n    // http://www.unicode.org/versions/Unicode6.1.0/ch03.pdf\n\n    {\n        const char *str = u8\"👨‍👩‍👧\";\n        int utf16length = utf16_length(str, strlen(str));\n        EXPECT_EQ(utf16length, 8);\n    }\n\n    {\n        const char *str = u8\"😂abcd\";\n        int utf16length = utf16_length(str, 4); // only for the first emoji\n        EXPECT_EQ(utf16length, 2);\n    }\n\n    {\n        const char *str = u8\"nanimo-*\";\n        auto utf16length = utf16_length(str, strlen(str));\n        EXPECT_EQ(utf16length, 8);\n    }\n\n    {\n        const char *str = u8\"a𐐀b\";\n        auto utf16length = utf16_length(str, strlen(str));\n        EXPECT_EQ(utf16length, 4);\n    }\n\n    {\n        const char *str = u8\"\\r\\n\\n\"; // line break\n        auto utf16length = utf16_length(str, strlen(str));\n        EXPECT_EQ(utf16length, 3);\n    }\n\n    {\n        const char *str = u8\" \"; // 1 space\n        auto utf16length = utf16_length(str, strlen(str));\n        EXPECT_EQ(utf16length, 1);\n    }\n\n    {\n        const char *str = u8\"\"; // empty string\n        auto utf16length = utf16_length(str, strlen(str));\n        EXPECT_EQ(utf16length, 0);\n    }\n\n    {\n        const char *str = u8\"Hasta el próximo miércoles\"; // spanish\n        auto utf16length = utf16_length(str, strlen(str));\n        EXPECT_EQ(utf16length, 26);\n    }\n\n    {\n        const char *str = u8\"de 13.0 と Emoji 13.0 に準拠した 😀😁😂などの色々な表情の顔文字や 👿悪魔 👹鬼 👺天狗 👽エイリアン 👻おばけ 😺ネコの顔文字と💘❤💓💔💕💖ハ\";\n        int utf16length = utf16_length(str, strlen(str));\n        EXPECT_EQ(utf16length, 96);\n    }\n\n    {\n        const char *str = u8\"我喜欢吃水果。Wǒ xǐhuan chī shuǐguǒ．私は果物が好きです。\";\n        int utf16length = utf16_length(str, strlen(str));\n        EXPECT_EQ(utf16length, 39);\n    }\n\n    {\n        const char *str = u8\"안녕하세요\";\n        int utf16length = utf16_length(str, strlen(str));\n        EXPECT_EQ(utf16length, 5);\n    }\n\n\n}\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "utf8ToCodePoint",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, utf8ToCodePoint) {\n\n    // Table 3-8.  Use of U+FFFD in UTF-8 Conversion\n     // http://www.unicode.org/versions/Unicode6.1.0/ch03.pdf\n    //char *str = u8\"😂日本語たち\";// u8\"nanimo-*\";// u8\"あいえおkん\";// \"👨‍👩‍👧\";\n    char *str = u8\"👨‍👩‍👧\";\n    unsigned int code_point, len, cursor, cursor_before;\n\n    len = strlen(str);\n    cursor = 0;\n\n    while (cursor < len) {\n        cursor_before = cursor;\n        code_point = utf8_get_next_char_or_ufffd((const unsigned char*)str, len, &cursor);\n        printf(\"U+%X カーソル:%d\\n\", ConvChU32ToU16(code_point), cursor_before);\n    }\n\n    //EXPECT_LT(one_op_nanosec, 40000);\n    //EXPECT_EQ(count, loopCount - 1);\n    //EXPECT_EQ(ch, ' ');\n\n}\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "JustScanLetters",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, JustScanLetters) {\n\n    auto start = std::chrono::high_resolution_clock::now().time_since_epoch();\n    uint64_t loopCount = 100 * 1000LLU;\n\n    std::string text = u8R\"(\nclass TestCl😂日本語10234ass {\n\n\n}\n\n\n\n\nclass a {\n\n}\nclass agiplkmp {\n\n}\n\nclass jips {\n\n}\n\n\n\n\n  )\";\n\n    unsigned long long count = 0;\n    const char *chars = text.c_str();\n    char ch = 'a';\n    for (unsigned long long i = 0; i < loopCount; i++) {\n        if (i > 5) {\n            for (uint_fast32_t k = 0; k < text.size(); k++) {\n                ch = chars[k];\n                if (ch == ' ') {\n                    count = i;\n                }\n                else if (ch == 'a') {\n                    count = i;\n                }\n            }\n        }\n    }\n\n    auto elapsed = std::chrono::high_resolution_clock::now().time_since_epoch() - start;\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\n    auto one_op_nanosec = nanoseconds / static_cast<double>(loopCount);\n\n    EXPECT_LT(one_op_nanosec, 40000);\n    EXPECT_EQ(count, loopCount - 1);\n    EXPECT_EQ(ch, ' ');\n\n}\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "ParserStream",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, ParserStream) {\n    FILE *fp;\n    size_t rsize;\n    int ret;\n    static constexpr int BUFFER_SIZE = 10240;\n    char buff[BUFFER_SIZE];\n\n    fp = stdin;// fopen(\"ConsoleApplication2.pdb\", \"rb\");\n\n    if (fp == nullptr) {\n        printf(\"failed to open file:errno=%d\\n\", errno);\n        return;\n    }\n\n    int totalByteCount = 0;\n    while (true) {\n        rsize = fread(buff, 1, BUFFER_SIZE, fp);\n        if (rsize > 0) {\n            totalByteCount += rsize;\n\n            printf(\"rsize=%d\\n\", rsize);\n            continue;\n        }\n\n        break;\n    }\n\n    printf(\"total=%d\\n\", totalByteCount);\n\n\n    if (feof(fp) == 0) {\n        printf(\"failed to read file: errno=%d\\n\", errno);\n        fclose(fp);\n        return;\n    }\n\n    ret = fclose(fp);\n\n    if (ret != 0) {\n        printf(\"failed to close file: errno=%d\\n\", errno);\n        return;\n    }\n\n    //EXPECT_EQ(3, 4);\n\n}\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "parser_benchmark",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, parser_benchmark) {\n\n\n    auto start = std::chrono::high_resolution_clock::now().time_since_epoch();\n    uint64_t loopCount = 100 * 1000LLU;\n    //std::string text = \"   class           A   {    }   \";\n    std::string text = u8R\"(\nclass TestCl😂日本語10234ass {\n\n\n}\n\n\n\n\nclass a {\n\n}\nclass agiplkmp {\n\n}\n\nclass jips {\n\n}\n\n \n\n\n  )\";\n\n    const char *chars = text.c_str();\n    for (unsigned long long i = 0; i < loopCount; i++) {\n        auto *document = Alloc::newDocument(DocumentType::CodeDocument, nullptr);\n        //VTables::DocumentVTable->init((NodeBase*)&document);\n        DocumentUtils::parseText(document, chars, text.size());\n\n        //EXPECT_EQ(document->nodeCount, 4);\n        Alloc::deleteDocument(document);\n        //console_log(\"i:\"+ std::to_string(i));\n    }\n\n    auto elapsed = std::chrono::high_resolution_clock::now().time_since_epoch() - start;\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\n    auto one_op_nanosec = nanoseconds / static_cast<double>(loopCount);\n\n    //EXPECT_LT(one_op_nanosec, 15000);\n    EXPECT_LT(one_op_nanosec, 35000);\n    std::cout << \"one\" << one_op_nanosec;\n}\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "aaHashMap",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, aaHashMap) {\n    {\n        char a = -122;\n        unsigned char b = a;\n        EXPECT_NE((int)a, (int)b);\n    }\n\n    {\n        auto hashKey = HashMap::calc_hash2(\"ak\", 10000);\n        auto hashKey2 = HashMap::calc_hash2(\"ka\", 10000);\n        EXPECT_NE(hashKey, hashKey2);\n    }\n\n    {\n        auto hashKey = HashMap::calc_hash2(\"N01\", 10000);\n        auto hashKey2 = HashMap::calc_hash2(\"N01234C\", 10000);\n        EXPECT_NE(hashKey, hashKey2);\n    }\n\n\n    for (int i = 0; i < 100; i++) {\n        HashMap *hashMap = simpleMalloc<HashMap>();\n        hashMap->init();\n        auto *first = Cast::upcast(simpleMalloc<DocumentStruct>());\n        const char key[] = \"firstAA\";\n        hashMap->put2(key, Cast::upcast(simpleMalloc<DocumentStruct>()));\n        hashMap->put2(key, first); // replace\n\n        hashMap->put2(\"secondBB\", Cast::upcast(simpleMalloc<DocumentStruct>()));\n        hashMap->put2(\"jfiow\", Cast::upcast(simpleMalloc<DocumentStruct>()));\n        hashMap->put(\"jfiow\", sizeof(\"jfiow\") - 1, Cast::upcast(simpleMalloc<DocumentStruct>()));\n\n        auto *node = hashMap->get2(\"firstAA\");\n        EXPECT_EQ(node, first);\n\n        node = hashMap->get2(\"jfiow\");\n        EXPECT_EQ(node != nullptr, true);\n        {\n            auto *node = hashMap->get2(\"empty\");\n            EXPECT_EQ(node, nullptr);\n        }\n\n        free(hashMap);\n    }\n\n}\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "charBuffer",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, charBuffer) {\n    auto start = std::chrono::high_resolution_clock::now().time_since_epoch();\n    uint64_t loopCount = 100 * 1000LLU;\n\n    CharBuffer<char> charBuffer;\n    charBuffer.init();\n\n\n    auto *chars = charBuffer.newChars(255);\n    EXPECT_EQ(charBuffer.firstBufferList, charBuffer.currentBufferList);\n\n    {\n        CharBuffer<char> charBuffer2;\n        charBuffer2.init();\n        {\n            auto *chars = charBuffer2.newChars(255);\n\n            EXPECT_EQ('\\0', *(chars + 254));\n            EXPECT_EQ(charBuffer2.currentBufferList, *((CharBuffer<char> **)(chars - sizeof(CharBuffer<char> *))));\n\n            charBuffer2.tryDelete(chars);\n        }\n\n        {\n            int size = 355;\n            auto *chars = charBuffer2.newChars(size);\n\n            EXPECT_EQ('\\0', *(chars + size - 1));\n            EXPECT_EQ(charBuffer2.currentBufferList, *((CharBuffer<char> **)(chars - sizeof(CharBuffer<char> *))));\n            charBuffer2.tryDelete(chars);\n\n        }\n    }\n\n\n    auto *chars2 = charBuffer.newChars(1);\n    EXPECT_NE(charBuffer.firstBufferList, charBuffer.currentBufferList);\n\n\n    auto elapsed = std::chrono::high_resolution_clock::now().time_since_epoch() - start;\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\n    auto one_op_nanosec = nanoseconds / static_cast<double>(loopCount);\n\n    EXPECT_LT(one_op_nanosec, 40000);\n}\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "CodeNode",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, CodeNode) {\n    std::string text = \"   class           A   {    }   \";\n    /*\n    std::string text = u8R\"(\nclass A {\n    class B {\n        class TestCl😂日本語10234ass {\n\n        }\n    }\n}\nclass A {}\nclass A {}\nclass A {}\nclass BDD{}\n\n\n\n\nclass AABC  {  }\n)\";\n    */\n\n    const char *chars = text.c_str();\n    auto *document = Alloc::newDocument(\n        DocumentType::CodeDocument, nullptr);\n\n    DocumentUtils::parseText(document, chars, text.size());\n\n    char *treeText = DocumentUtils::getTextFromTree(document);\n    EXPECT_EQ(std::string(treeText), std::string(chars));\n    EXPECT_EQ(strlen(treeText), strlen(chars));\n\n    Alloc::deleteDocument(document);\n\n}\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "ErrorNodeTest_class",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, ErrorNodeTest_class) {\n    std::string text = u8R\"(\nclass A {\n    class B {\n        class TestCl😂日本語10234ass {\n\n        }\n\n        class C { }\n    }\n}\n)\";\n\n    const char *chars = text.c_str();\n    auto *document = Alloc::newDocument(DocumentType::CodeDocument, nullptr);\n\n    DocumentUtils::parseText(document, chars, text.size());\n\n    char *treeText = DocumentUtils::getTextFromTree(document);\n    EXPECT_EQ(std::string(treeText), std::string(chars));\n    EXPECT_EQ(strlen(treeText), strlen(chars));\n\n    Alloc::deleteDocument(document);\n\n}\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "ErrorNodeTest",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, ErrorNodeTest) {\n    return;\n    //std::string text = \"   class           A   {    }   \";\n    std::string text = u8R\"(\nclass A {\n\n    class B {\n        @hoge(akaw=3242, ajwe=2342)\n        class TestCl😂日本語10234ass {\n            \n        }\n\n        cmpl fn fawe() {\n\n        }\n    }\n}\nclass A {}\nclass A {}\nclass A {}\nclass BDD{}\n\n\n\n\nclass AABC  {  }\n)\";\n\n    const char *chars = text.c_str();\n    auto *document = Alloc::newDocument(DocumentType::CodeDocument, nullptr);\n\n    DocumentUtils::parseText(document, chars, text.size());\n\n    char *treeText = DocumentUtils::getTextFromTree(document);\n    EXPECT_EQ(std::string(treeText), std::string(chars));\n    EXPECT_EQ(strlen(treeText), strlen(chars));\n\n    Alloc::deleteDocument(document);\n\n}\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "IndentTextTest",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, IndentTextTest) {\n    std::string text = u8R\"(\nclass A {\n    class B {\n        class TestCl😂日本語10234ass {\n\n        }\n    }\n}\n)\";\n\n    std::string textWithIndent = u8R\"(\nclass A {\n    class B {\n        class TestCl😂日本語10234ass {\n            func(32423, ()=>{\n                var a = 2342;\n            }, 432);\n)\";\n\n    textWithIndent += \"            \";\n\n    textWithIndent += u8R\"(\n        }\n    }\n}\n)\";\n\n\n    const char *chars = text.c_str();\n    const char *indentChars = textWithIndent.c_str();\n    auto *document = Allocator::newDocument(DocumentType::CodeDocument, nullptr);\n\n    DocumentUtils::parseText(document, chars, text.size());\n\n    char *treeText = DocumentUtils::getTextFromTree(document);\n    EXPECT_EQ(std::string(treeText), std::string(indentChars));\n    EXPECT_EQ(strlen(treeText), strlen(chars));\n\n    Allocator::deleteDocument(document);\n\n}\n\n"
	},
	{
		"testcasename": "parser_test",
		"testname": "ParseUtil",
		"filepath": "tests/google_tests/parser_test.cpp",
		"filename": "parser_test.cpp",
		"body": "TEST(parser_test, ParseUtil) {\n\n    EXPECT_EQ(true, ParseUtil::isIdentifierLetter('a'));\n\n    ParseUtil::letterCheck(&func);\n\n\n\n    EXPECT_EQ(true, ParseUtil::isIdentifierLetter('a'));\n    EXPECT_EQ(true, ParseUtil::isIdentifierLetter(std::string{ u8\"😂\" }.c_str()[0]));\n    EXPECT_EQ(false, ParseUtil::isIdentifierLetter('\\n'));\n\n\n    EXPECT_EQ(0, ParseUtil::matchFirstWithTrim(\"class A{}\", \"class\"));\n\n    EXPECT_EQ(-1, ParseUtil::matchFirstWithTrim(\"\", \"class\"));\n    EXPECT_EQ(-1, ParseUtil::matchFirstWithTrim(\"\", \"\"));\n\n    {\n        std::string class_text(u8\"     \\tclassauto * 😂日本語=10234;\");\n        int index = ParseUtil::matchFirstWithTrim(class_text.c_str(), \"class\", 0);\n        EXPECT_EQ(index, 6);\n    }\n\n\n    {\n        std::string class_text(u8\"😂classauto;\");\n        int index = ParseUtil::matchFirstWithTrim(class_text.c_str(), \"class\", 0);\n        EXPECT_EQ(index, -1);\n    }\n\n\n    // matchWord\n    {\n        std::string class_text(u8\"class\");\n        EXPECT_EQ(class_text.length(), 5);\n        auto result = ParseUtil::matchWord(class_text.c_str(), class_text.length(), \"class\", 5, 0);\n        EXPECT_EQ(result, true);\n    }\n\n    {\n        std::string class_text(u8\" class\");\n        auto result = ParseUtil::matchWord(class_text.c_str(), class_text.length(), \"class\", 5, 0);\n        EXPECT_EQ(result, false);\n    }\n\n    {\n        std::string class_text(u8\"abcclass\");\n        auto result = ParseUtil::matchWord(class_text.c_str(), class_text.length(), \"class\", 5, 3);\n        EXPECT_EQ(result, true);\n    }\n\n    {\n        std::string class_text(u8\"classauto;\");\n        auto result = ParseUtil::matchWord(class_text.c_str(), class_text.length(), \"class\", 5, 0);\n        EXPECT_EQ(result, true);\n    }\n\n    {\n        std::string text(u8\"ab\");\n        auto result = ParseUtil::matchWord(text.c_str(), text.length(), \"abcdefg\", 5, 0);\n        EXPECT_EQ(result, false);\n    }\n\n}\n\n"
	},
	{
		"testcasename": "SpeedTest",
		"testname": "memory_order_relaxed_is_fast",
		"filepath": "tests/google_tests/speed_test.cpp",
		"filename": "speed_test.cpp",
		"body": "TEST(SpeedTest, memory_order_relaxed_is_fast) {\r\n\r\n    EXPECT_EQ(true, ParseUtil::isIdentifierLetter('a'));\r\n\r\n\r\n    auto start = std::chrono::high_resolution_clock::now().time_since_epoch();\r\n\r\n    uint64_t loopCount = 1000 * 10 * 1000LLU;\r\n    std::atomic<uint64_t> *current = new std::atomic<uint64_t>();\r\n    current->store(9823, std::memory_order_relaxed);\r\n\r\n    //long kkk;\r\n    P *p = new P();//uint64_t(33);\r\n    int *a = NULL;\r\n    int *newValue = new int{ 3 };\r\n\r\n    for (unsigned long long i = 0; i < loopCount; i++) {\r\n        if (i > 5) {\r\n            current->store(i, std::memory_order_relaxed);\r\n            a = newValue;\r\n            //InterlockedExchangePointerNoFence((PVOID *)&a, newValue);\r\n\r\n        }\r\n        else {\r\n            a = NULL;// newValue;\r\n\r\n        }\r\n        //current->compare_exchange_weak(loopCount, loopCount+1);\r\n\r\n        //p->a = static_cast<int>(i);\r\n        //do{} while(0); //noop\r\n//        kkk = current->load(std::memory_order_relaxed);\r\n    }\r\n\r\n    auto elapsed = std::chrono::high_resolution_clock::now().time_since_epoch() - start;\r\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n    auto one_op_nanosec = nanoseconds / static_cast<double>(loopCount);\r\n\r\n    if (speed_test) {\r\n        EXPECT_LT(one_op_nanosec, ARM ? 40 : 1.1);\r\n        printf(\"%f\", one_op_nanosec);\r\n    }\r\n    EXPECT_EQ(current->load(), loopCount - 1);\r\n}\r\n\r\n"
	},
	{
		"testcasename": "SpeedTest",
		"testname": "try_catch_is_slow",
		"filepath": "tests/google_tests/speed_test.cpp",
		"filename": "speed_test.cpp",
		"body": "TEST(SpeedTest, try_catch_is_slow) {\r\n\r\n    auto start = std::chrono::high_resolution_clock::now();\r\n\r\n    uint64_t loopCount = 1000 * 1000LLU;\r\n    int a = 0;\r\n\r\n    try {\r\n        for (int i = 0; i < loopCount; i++) {\r\n            a = i;\r\n        }\r\n    }\r\n    catch (...) {\r\n        std::exception_ptr p = std::current_exception();\r\n        printf(\"std::exception_ptr\\n\");\r\n\r\n    }\r\n\r\n    auto elapsed = std::chrono::high_resolution_clock::now() - start;\r\n    auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n    auto one_op_nanosec = nanoseconds / static_cast<double>(loopCount);\r\n\r\n    // we have to use a once\r\n    printf(\"a = %d\", a);\r\n\r\n    if (ARM) {\r\n        EXPECT_LT(one_op_nanosec, 15);\r\n    } else {\r\n        EXPECT_GT(one_op_nanosec, 0.02);\r\n        EXPECT_LT(one_op_nanosec, 4);\r\n    }\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "SpeedTest",
		"testname": "stack_assign_is_fast",
		"filepath": "tests/google_tests/speed_test.cpp",
		"filename": "speed_test.cpp",
		"body": "TEST(SpeedTest, stack_assign_is_fast) {\r\n    {\r\n        auto start = std::chrono::high_resolution_clock::now();\r\n\r\n        const int64_t loopCount = 1000 *     1000LL;\r\n        int current = 0;//int{};\r\n        long long current32 = 0;\r\n        auto *aData = new AData{};\r\n        auto *current2 = &aData->a;\r\n        int lim = loopCount - 15;\r\n        for (int i = 0; i < loopCount; i++) {\r\n            if (i > lim) {\r\n                current = i;\r\n            }\r\n        }\r\n\r\n        auto elapsed = std::chrono::high_resolution_clock::now() - start;\r\n        auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n\r\n        auto one_op_nanosec = nanoseconds / static_cast<double>(loopCount);\r\n\r\n        GLOG << nanoseconds/1000000.0 << \"ms\";\r\n\r\n        EXPECT_LT(one_op_nanosec, ARM ? 10.0: 2.0);\r\n        EXPECT_EQ(current, loopCount - 1);\r\n        //EXPECT_EQ(*current2, loopCount - 1);\r\n    }\r\n#ifdef  __MYWIN__\r\n\r\n    //_mm_pause() takes more than 0.5us\r\n   {\r\n       const auto start = std::chrono::high_resolution_clock::now();\r\n\r\n       int64_t max = 1000 * 100LL;\r\n       for (long long i = 0; i < max; i++) {\r\n           _mm_pause();\r\n       }\r\n\r\n       auto elapsed = std::chrono::high_resolution_clock::now() - start;\r\n       auto nano_elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(elapsed).count();\r\n\r\n       EXPECT_GT(nano_elapsed, max * 0.5);\r\n\r\n       if (os_type == OS_TYPE::Windows) {\r\n           EXPECT_LT(nano_elapsed, max * 90); // 90 nano seconds\r\n       }\r\n       else if (os_type == OS_TYPE::Mac) { // Mac\r\n           EXPECT_LT(nano_elapsed, max * 130);\r\n       }\r\n       else { // linux\r\n           EXPECT_LT(nano_elapsed, max * 90);//16\r\n       }\r\n\r\n   }\r\n#endif\r\n\r\n}\r\n\r\n"
	},
	{
		"testcasename": "SpeedTest",
		"testname": "functor",
		"filepath": "tests/google_tests/speed_test.cpp",
		"filename": "speed_test.cpp",
		"body": "TEST(SpeedTest, functor) {\r\n    /*\r\n    int var = Fx([&](const int x) {\r\n        int kk = 8;\r\n        return kk;\r\n    })(200);\r\n    */\r\n\r\n    //std::cout << \"argument function : \" << var << std::endl;\r\n\r\n    auto gfunc = &fff_ori;\r\n    auto &&gfunc2 = gfunc;\r\n    auto result = (*gfunc2)(3);\r\n    SetStateProc(handle1);\r\n    auto state_proc2 = *state_proc;\r\n\r\n    //fff(5);\r\n    //auto fff_ori2 = gfunc;\r\n    //k2 = gfunc2(3);\r\n\r\n\r\n    //std::function<const int(const int)> &&fff = std::move(fff_ori);\r\n\r\n    //int k = state_proc2(3);\r\n    //int k = (*state_proc)(3);\r\n    //fff_ori(5);\r\n\r\n\r\n    EXPECT_EQ(10, 10);\r\n}\r\n\r\n"
	}
]